@page "/"
@rendermode InteractiveServer
@using ItsAllSemantics.Web.Models
@implements IDisposable
@inject NavigationManager Nav
@inject IJSRuntime JS
@inject ILogger<Chat>? Log

<PageTitle>Chat</PageTitle>

@using Microsoft.AspNetCore.Components

<section class="flex flex-col flex-1 h-full min-h-0">
    <div class="chat-shell w-full flex flex-col flex-1 relative min-h-0 @ChatFontClass">
    <div id="chat-window" class="chat-window edge-scroll flex-1 overflow-y-auto min-h-0 @ChatFontClass">
            <div class="max-w-4xl mx-auto w-full px-4 pt-6 pb-20 space-y-6">
        @if (messages is { Count: > 0 })
        {
            @foreach (var message in messages)
            {
                var isUser = message.IsUser;
                <div class="flex @(isUser ? "justify-end" : "justify-start")" style="max-width:100%;">
                    <div class="chat-bubble @(isUser ? "from-user" : (message.IsError ? "from-ai error" : "from-ai"))">
                        <div class="bubble-meta">
                            @if (isUser)
                            {
                                <i class="fa-solid fa-user"></i>
                                <span>You</span>
                            }
                            else
                            {
                                if (!string.IsNullOrWhiteSpace(message.Agent))
                                {
                                    <span class="agent-avatar @GetAgentAvatarClass(message.Agent)" title="@message.Agent">@GetAgentAvatarLabel(message.Agent)</span>
                                    <span>@message.Agent</span>
                                }
                                else
                                {
                                    <i class="fa-solid fa-robot"></i>
                                    <span>Assistant</span>
                                }
                                @if (message.IsError)
                                {
                                    <span class="ml-2 text-red-400 font-semibold" title="@message.ErrorCode">error</span>
                                }
                            }
                            <time>@message.Timestamp.LocalDateTime.ToString("t")</time>
                        </div>
                        <div class="bubble-text">@message.Text</div>
                    </div>
                </div>
            }
        }
        else
        {
            <p class="text-slate-400 text-sm">No messages yet. Say hello!</p>
        }

            @if (isStreaming)
            {
                if (isConcurrentMode && agentStreams.Count > 0)
                {
                    <div class="space-y-3">
                        @foreach (var kvp in agentStreams.OrderBy(k => k.Key))
                        {
                            var agentName = kvp.Key;
                            var s = kvp.Value;
                            <div class="flex justify-start" style="max-width:100%;">
                                <div class="chat-bubble from-ai streaming">
                                    <div class="bubble-meta">
                                        <span class="agent-avatar @GetAgentAvatarClass(agentName)" title="@agentName">@GetAgentAvatarLabel(agentName)</span>
                                        <span>@agentName</span>
                                        <span class="ml-2 text-[10px] opacity-60">@s.TokenCount tok</span>
                                        @if (!s.Completed) { <span class="ml-1 animate-pulse text-[9px] opacity-60">…</span>; }
                                        <time>@DateTime.Now.ToString("t")</time>
                                    </div>
                                    <div class="bubble-text">@s.Buffer<span class="ias-caret"></span></div>
                                </div>
                            </div>
                        }
                    </div>
                }
                else
                {
                    <div class="flex justify-start" style="max-width:100%;">
                        <div class="chat-bubble from-ai streaming">
                            <div class="bubble-meta">
                                @if (!string.IsNullOrWhiteSpace(currentAgent))
                                {
                                    <span class="agent-avatar @GetAgentAvatarClass(currentAgent)" title="@currentAgent">@GetAgentAvatarLabel(currentAgent)</span>
                                    <span>@currentAgent</span>
                                }
                                else
                                {
                                    <i class="fa-solid fa-robot"></i>
                                    <span>Assistant</span>
                                }
                                <span class="ml-2 text-[10px] opacity-60">@currentTokenCount tok</span>
                                <time>@DateTime.Now.ToString("t")</time>
                            </div>
                            <div class="bubble-text">@streamingText<span class="ias-caret"></span></div>
                        </div>
                    </div>
                }
            }
            </div>
        </div>

    @if (isWaitingForResponse && !isStreaming)
    {
        <div class="text-xs text-slate-400">AI is typing…</div>
    }

    <form @onsubmit="HandleSubmit" @onsubmit:preventDefault class="chat-input-container sticky bottom-0 left-0 right-0 z-20 px-4 pb-2 pt-3 backdrop-blur-sm @ChatFontClass">
            <div class="bg-[#3b3a3f]/95 border border-[#494b53] rounded-xl p-2 flex flex-col gap-2 shadow-xl ring-1 ring-black/40">
                <div class="flex justify-between items-center px-1">
                    <div class="text-[11px] uppercase tracking-wide text-slate-400">Chat</div>
                    <button type="button" class="text-[11px] px-2 py-0.5 rounded border border-[#494b53] hover:bg-[#494b53] transition" @onclick="() => ToggleDiagnostics()">
                        @(showDiagnostics ? "Hide Diagnostics" : "Show Diagnostics")
                    </button>
                </div>
                <textarea @bind="pendingMessage" @bind:event="oninput" rows="1" data-autosize data-chat-input
                          placeholder="Message ItsAllSemantics..." class="w-full bg-transparent focus:outline-none p-2 text-[#FCFCFA] resize-none leading-6 custom-scrollbar max-h-56 overflow-y-auto @ChatFontClass"></textarea>
                <div class="flex justify-end gap-2">
                    @if (isStreaming && currentStreamId is not null)
                    {
                        <button type="button" @onclick="CancelActive"
                            class="bg-[#FF6188] hover:bg-[#FC9867] transition-colors text-[#2D2A2E] font-bold w-10 h-10 flex items-center justify-center rounded-full disabled:opacity-40 disabled:cursor-not-allowed"
                            disabled="@cancelRequested" title="Cancel generation" aria-label="Cancel generation">
                            <i class="fas fa-stop"></i>
                        </button>
                    }
                    else
                    {
                        <button type="submit" data-ias-send aria-label="Send" title="Send"
                            class="bg-[#78DCE8] hover:bg-[#A9DC76] transition-colors text-[#2D2A2E] font-bold w-10 h-10 flex items-center justify-center rounded-full disabled:opacity-40 disabled:cursor-not-allowed"
                            disabled="@string.IsNullOrWhiteSpace(pendingMessage)">
                            <i class="fas fa-arrow-up"></i>
                        </button>
                    }
                </div>
            </div>
        </form>
    </div>
</section>

@if (showDiagnostics)
{
    <div class="fixed bottom-24 right-4 w-96 max-h-[50vh] overflow-y-auto text-xs bg-[#2d2a2e]/95 backdrop-blur border border-[#494b53] rounded-lg shadow-xl p-3 space-y-2 custom-scrollbar">
        <div class="flex justify-between items-center">
            <div class="font-semibold text-[#a9dc76]">Streaming Diagnostics</div>
            <button class="text-[10px] px-2 py-0.5 rounded border border-[#494b53] hover:bg-[#494b53]" @onclick="()=>{ diagnosticsEvents.Clear(); StateHasChanged(); }">Clear</button>
        </div>
        <div class="grid grid-cols-1 gap-1">
            @if (diagnosticsEvents.Count == 0)
            {
                <div class="text-slate-400">No events captured yet.</div>
            }
            else
            {
                @foreach (var ev in diagnosticsEvents.TakeLast(400).Reverse())
                {
                    var cls = ev.TryGetValue("_event", out var kind) ? kind switch { "delta" => "text-[#78dce8]", "error" => "text-[#ff6188]", "end" => "text-[#a9dc76]", _ => "text-slate-300" } : "text-slate-300";
                    <div class="border border-[#494b53] rounded px-2 py-1 leading-4 break-words">
                        <div class="font-mono text-[10px] @cls">
                            @if (ev.TryGetValue("_event", out var ek)) { <span>@ek</span>; }
                            @if (ev.TryGetValue("globalSeq", out var gs)) { <span> g:@gs</span>; }
                            @if (ev.TryGetValue("agentSeq", out var ags)) { <span> a:@ags</span>; }
                            @if (ev.TryGetValue("tokenCount", out var tk)) { <span> tok:@tk</span>; }
                            @if (ev.TryGetValue("_deltaLen", out var dl)) { <span> len:@dl</span>; }
                            @if (ev.TryGetValue("status", out var st)) { <span> status:@st</span>; }
                        </div>
                    </div>
                }
            }
        </div>
    </div>
}

@code {
    [CascadingParameter] public string? ChatFontClass { get; set; }
    private readonly List<ChatMessageModel> messages = [];
    private HubConnection? hubConnection;
    private string? pendingMessage;
    private bool isWaitingForResponse;
    private bool isStreaming;
    private string? currentStreamId;
    private bool cancelRequested;
    private string? currentAgent;
    private int currentTokenCount;
        private bool showDiagnostics;
        private List<Dictionary<string,string>> diagnosticsEvents = new();
    private string streamingText = string.Empty; // single-mode buffer
    private bool isConcurrentMode;
    private readonly Dictionary<string, AgentStreamState> agentStreams = new();
    private long typingTicket;
    private System.Threading.Timer? _renderTimer;

    private int _lastMessageCount;
    private int _lastStreamingLength;
    private long _lastRenderTicks;
    private DateTime _lastScrollAt = DateTime.MinValue;

    protected override async Task OnInitializedAsync()
    {
        var baseUri = Nav.BaseUri.TrimEnd('/');
        hubConnection = new HubConnectionBuilder()
            .WithUrl(new Uri(new Uri(baseUri + "/"), "hubs/chat"), options =>
            {
                options.SkipNegotiation = false;
                options.Transports = Microsoft.AspNetCore.Http.Connections.HttpTransportType.WebSockets;
            })
            .WithAutomaticReconnect()
            .ConfigureLogging(lb =>
            {
                lb.SetMinimumLevel(LogLevel.Warning);
                lb.AddFilter("Microsoft.AspNetCore.SignalR", LogLevel.Warning);
                lb.AddFilter("Microsoft.AspNetCore.Http.Connections", LogLevel.Warning);
                lb.AddConsole();
            })
            .Build();

        hubConnection.On<ChatMessageModel>("ReceiveMessage", async (msg) =>
        {
            messages.Add(msg);
            if (!msg.IsUser) isWaitingForResponse = false;
            await InvokeAsync(StateHasChanged);
        });

        hubConnection.On<string, string, Dictionary<string, string>>("ReceiveStreamStart", async (streamId, agent, meta) =>
        {
            isStreaming = true;
            streamingText = string.Empty;
            isWaitingForResponse = false;
            currentStreamId = streamId;
            cancelRequested = false;
            currentAgent = agent;
            currentTokenCount = 0;
            isConcurrentMode = meta.TryGetValue("mode", out var modeVal) && modeVal == "concurrent";
            agentStreams.Clear();
                if (showDiagnostics) diagnosticsEvents.Add(new Dictionary<string,string>(meta) { ["_event"] = "start" });
            _renderTimer = new System.Threading.Timer(_ =>
            {
                InvokeAsync(async () =>
                {
                    StateHasChanged();
                    await Task.Delay(1);
                    await JS.InvokeVoidAsync("ias.scrollToBottom", "#chat-window");
                });
            }, null, TimeSpan.FromMilliseconds(100), TimeSpan.FromMilliseconds(100));
            await InvokeAsync(StateHasChanged);
        });

        hubConnection.On<string, Dictionary<string, string>>("ReceiveStreamDelta", async (delta, meta) =>
        {
            await InvokeAsync(() =>
            {
                if (isConcurrentMode && meta.TryGetValue("agent", out var ag))
                {
                    if (!agentStreams.TryGetValue(ag, out var st))
                    {
                        st = new AgentStreamState();
                        agentStreams[ag] = st;
                    }
                    if (!string.IsNullOrEmpty(delta)) st.Buffer.Append(delta);
                    if (!string.IsNullOrEmpty(delta)) st.TokenCount++;
                    currentTokenCount++;
                    if (meta.TryGetValue("status", out var stat) && stat == "agent-end") st.Completed = true;
                }
                else
                {
                    streamingText += delta;
                    currentTokenCount++;
                }
                    if (showDiagnostics)
                    {
                        var copy = new Dictionary<string,string>(meta) { ["_event"] = "delta", ["_deltaLen"] = delta.Length.ToString() };
                        diagnosticsEvents.Add(copy);
                    }
                StateHasChanged();
            });
        });

        hubConnection.On<Dictionary<string, string>>("ReceiveStreamEnd", async meta =>
        {
            _renderTimer?.Dispose();
            _renderTimer = null;
            isStreaming = false;
            if (isConcurrentMode && agentStreams.Count > 0)
            {
                foreach (var kvp in agentStreams.OrderBy(k => k.Key))
                {
                    var ag = kvp.Key; var st = kvp.Value;
                    messages.Add(new ChatMessageModel(st.Buffer.ToString(), "ai", DateTimeOffset.Now) { TokenCount = st.TokenCount, Agent = ag });
                }
            }
            else
            {
                int? finalTokens = null;
                if (meta.TryGetValue("tokenCount", out var tc) && int.TryParse(tc, out var tcParsed)) finalTokens = tcParsed;
                messages.Add(new ChatMessageModel(streamingText, "ai", DateTimeOffset.Now) { TokenCount = finalTokens, Agent = currentAgent });
            }
            streamingText = string.Empty;
            currentStreamId = null;
            currentAgent = null;
            cancelRequested = false;
            agentStreams.Clear();
                if (showDiagnostics)
                {
                    var copy = new Dictionary<string,string>(meta) { ["_event"] = "end" };
                    diagnosticsEvents.Add(copy);
                }
            await InvokeAsync(StateHasChanged);
        });

        hubConnection.On<string, string, bool, Dictionary<string, string>>("ReceiveStreamError", async (code, message,
        isTransient, meta) =>
        {
            _renderTimer?.Dispose();
            _renderTimer = null;
            var canceled = code == "Canceled";
            var text = string.IsNullOrWhiteSpace(streamingText)
    ? (canceled ? "[canceled]" : message)
    : streamingText + (canceled ? "\n[canceled]" : "\n[error] " + message);
            isStreaming = false;
            if (!canceled)
            {
                messages.Add(new ChatMessageModel(text, "ai", DateTimeOffset.Now) { ErrorCode = code });
            }
            else
            {
                messages.Add(new ChatMessageModel(text, "ai", DateTimeOffset.Now));
            }
            streamingText = string.Empty;
            currentStreamId = null;
            currentAgent = null;
            cancelRequested = false;
                if (showDiagnostics)
                {
                    var copy = new Dictionary<string,string>(meta) { ["_event"] = "error", ["_code"] = code };
                    diagnosticsEvents.Add(copy);
                }
            await InvokeAsync(StateHasChanged);
        });

        await hubConnection.StartAsync();
        Log?.LogInformation("[CLIENT] Hub connected at={Time}", DateTime.UtcNow.ToString("O"));

        messages.Add(new ChatMessageModel("Hello! I’m your AI assistant.", "ai", DateTimeOffset.Now));
    }

    private async Task HandleSubmit()
    {
        if (string.IsNullOrWhiteSpace(pendingMessage) || hubConnection is null || isStreaming) return;
    var text = pendingMessage;
    pendingMessage = string.Empty; // hub echo will add user message

        var ticket = System.Threading.Interlocked.Increment(ref typingTicket);
        isWaitingForResponse = true;
        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(TimeSpan.FromSeconds(30));
                if (System.Threading.Volatile.Read(ref typingTicket) == ticket && isWaitingForResponse)
                {
                    isWaitingForResponse = false;
                    await InvokeAsync(StateHasChanged);
                }
            }
            catch { }
        });

        try
        {
            await hubConnection.SendAsync("SendMessage", text);
        }
        catch (Exception ex)
        {
            Log?.LogWarning(ex, "Send failed");
            if (System.Threading.Volatile.Read(ref typingTicket) == ticket)
            {
                isWaitingForResponse = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            var count = messages.Count;
            var streamLen = isStreaming ? streamingText.Length : 0;
            if (count != _lastMessageCount || streamLen != _lastStreamingLength)
            {
                _lastMessageCount = count;
                _lastStreamingLength = streamLen;
                var now = System.Diagnostics.Stopwatch.GetTimestamp();
                var dt = (_lastRenderTicks == 0) ? 0 : (now - _lastRenderTicks) * 1000.0 / System.Diagnostics.Stopwatch.Frequency;
                _lastRenderTicks = now;
                Log?.LogDebug("[RENDER] Chat scroll -> msgs={Msgs} streamLen={Len} dtSinceLastRender={DtMs:F1}ms", count, streamLen, dt);
                if (isStreaming)
                {
                    if ((DateTime.UtcNow - _lastScrollAt) > TimeSpan.FromMilliseconds(100))
                    {
                        _lastScrollAt = DateTime.UtcNow;
                        _ = JS.InvokeVoidAsync("ias.scrollToBottom", "#chat-window");
                    }
                }
                else
                {
                    await JS.InvokeVoidAsync("ias.scrollToBottom", "#chat-window");
                }
            }
        }
    }

    public void Dispose()
    {
        _renderTimer?.Dispose();
        hubConnection?.DisposeAsync();
    }

    private async Task CancelActive()
    {
        if (hubConnection is null || currentStreamId is null) return;
        try
        {
            Log?.LogInformation("[CLIENT] Cancellation requested streamId={StreamId}", currentStreamId);
            cancelRequested = true;
            await hubConnection.SendAsync("CancelStream", currentStreamId);
        }
        catch (Exception ex)
        {
            Log?.LogWarning(ex, "Cancel failed");
            cancelRequested = false;
        }
        await InvokeAsync(StateHasChanged);
    }

    private void ToggleDiagnostics()
    {
        showDiagnostics = !showDiagnostics;
        StateHasChanged();
    }

    private sealed class AgentStreamState
    {
        public System.Text.StringBuilder Buffer { get; } = new();
        public int TokenCount { get; set; }
        public bool Completed { get; set; }
    }

    private static string GetAgentAvatarClass(string agent) => agent?.Trim().ToLowerInvariant() switch
    {
        "echoer" => "agent-echoer",
        "fetcher" => "agent-fetcher",
        "orchestrator" => "agent-orchestrator",
        "summarizer" => "agent-summarizer",
        "expander" => "agent-expander",
        _ => "agent-default"
    };

    private static string GetAgentAvatarLabel(string agent)
    {
        if (string.IsNullOrWhiteSpace(agent)) return "?";
        // Use first letter; optionally special symbols
        return agent.Trim()[0].ToString().ToUpperInvariant();
    }
}
